# Plant Monitoring Camera and AI Processing Unit 
# Raspberry Pi 3,4 or 5

##########################################################################################################

import cv2
import numpy as np
import time
import requests
import tflite_runtime.interpreter as tflite

# Paths / Settings
MODEL_PATH   = "/home/malek3/Downloads/G_A_mnet_float32msf.tflite"
CLASSES_PATH = "/home/malek3/Downloads/G&A_mlnet.txt"
CAM_INDEX    = 0

CONF_THR   = 0.70
MARGIN_THR = 0.10

USE_GREEN_FILTER = True
GREEN_RATIO_THR  = 0.10
MIN_ROI_AREA     = 3000  

# SETTINGS
TFLITE_THREADS   = 2 
PREDICT_EVERY_N  = 3 
FAST_MASK        = True

# ROI/Mask 
PROC_W, PROC_H = 400, 320

# cam Settings
SET_CAM_RESOLUTION = True
CAM_W, CAM_H = 900, 640
SET_CAM_FPS = True
CAM_FPS = 23

RESIZE_WINDOWS = True
WIN_MAIN_W, WIN_MAIN_H = 720, 540
WIN_MASK_W, WIN_MASK_H = 420, 240   

# Blynk (live)
BLYNK_TOKEN = "uk45alNPTWoguEuJUUqhGy3Fi232LF44"
BLYNK_EVENT_CODE = "leaf_disease"

DISEASE_LABELS = {
    "Apple___Apple_scab",
    "Apple___Black_rot",
    "Apple___Cedar_apple_rust",
    "Grape___Black_rot",
    "Grape___Esca_(Black_Measles)",
    "Grape___Leaf_blight_(Isariopsis_Leaf_Spot)",
}
HEALTHY_LABELS = {
    "Apple___healthy",
    "Grape___healthy",
}

# Alert control 
ALERT_MIN_CONF      = 0.75
ALERT_COOLDOWN_SEC  = 121
REPEAT_REQUIRED     = 3

_last_alert_time  = 0.0
_last_sent_label  = None
_repeat_label     = None
_repeat_count     = 0

def blynk_log_event(event_code: str, description: str):
    url = "https://blynk.cloud/external/api/logEvent"
    try:
        r = requests.get(url, params={
            "token": BLYNK_TOKEN,
            "code": event_code,
            "description": description
        }, timeout=5)
        print("Blynk:", r.status_code, r.text)
    except Exception as e:
        print("Blynk error:", e)

def blynk_write(vpin: int, value):
    url = "https://blynk.cloud/external/api/update"
    try:
        requests.get(url, params={"token": BLYNK_TOKEN, f"v{vpin}": value}, timeout=3)
    except:
        pass

def handle_alerts(top1_name: str, top1_conf: float):
    """Send Blynk event when disease is confirmed + update live pins."""
    global _last_alert_time, _last_sent_label, _repeat_label, _repeat_count

    # live values 
    if BLYNK_TOKEN:
        blynk_write(10, top1_name)              # V10 = label
        blynk_write(11, int(top1_conf * 100))   # V11 = confidence %

    # ignore healthy / unknown
    if (top1_name in HEALTHY_LABELS) or (top1_name not in DISEASE_LABELS):
        _repeat_label = None
        _repeat_count = 0
        return

    if top1_conf < ALERT_MIN_CONF:
        return

    # require repeated detection
    if _repeat_label == top1_name:
        _repeat_count += 1
    else:
        _repeat_label = top1_name
        _repeat_count = 1

    now = time.time()
    if _repeat_count >= REPEAT_REQUIRED:
        if (now - _last_alert_time) >= ALERT_COOLDOWN_SEC or (_last_sent_label != top1_name):
            msg = f"Disease detected: {top1_name} ({top1_conf*100:.1f}%)"
            blynk_log_event(BLYNK_EVENT_CODE, msg)

            _last_alert_time = now
            _last_sent_label = top1_name
            _repeat_count = 0


# Load classes
classes = []
with open(CLASSES_PATH, "r", encoding="utf-8") as f:
    for line in f:
        line = line.strip()
        if not line:
            continue
        if "\t" in line:
            _, name = line.split("\t", 1)
            classes.append(name.strip())
        else:
            classes.append(line)

print("Classes loaded:", len(classes))


# Load TFLite
interpreter = tflite.Interpreter(model_path=MODEL_PATH, num_threads=TFLITE_THREADS)
interpreter.allocate_tensors()

in_det  = interpreter.get_input_details()[0]
out_det = interpreter.get_output_details()[0]

in_shape = in_det["shape"]
in_h, in_w = int(in_shape[1]), int(in_shape[2])
in_dtype = in_det["dtype"]

print("Model Input :", in_shape, in_dtype)
print("Model Output:", out_det["shape"], out_det["dtype"])


# Green mask
def green_mask_and_ratio(bgr_small):
    hsv = cv2.cvtColor(bgr_small, cv2.COLOR_BGR2HSV)

    lower1 = np.array([25,  40,  30], dtype=np.uint8)
    upper1 = np.array([85, 255, 255], dtype=np.uint8)

    mask = cv2.inRange(hsv, lower1, upper1)

    if FAST_MASK:
        mask = cv2.GaussianBlur(mask, (5,5), 0)
        kernel = np.ones((5, 5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=1)
    else:
        mask = cv2.medianBlur(mask, 5)
        kernel = np.ones((5, 5), np.uint8)
        mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel, iterations=1)
        mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel, iterations=2)

    ratio = mask.mean() / 255.0
    return mask, ratio

def crop_leaf_roi_fast(frame_bgr):
    small = cv2.resize(frame_bgr, (PROC_W, PROC_H), interpolation=cv2.INTER_AREA)
    mask, ratio = green_mask_and_ratio(small)

    if ratio < GREEN_RATIO_THR:
        return None, mask, ratio, None

    cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    if not cnts:
        return None, mask, ratio, None

    c = max(cnts, key=cv2.contourArea)
    area = cv2.contourArea(c)
    if area < MIN_ROI_AREA:
        return None, mask, ratio, None

    x, y, w0, h0 = cv2.boundingRect(c)

    sx = frame_bgr.shape[1] / PROC_W
    sy = frame_bgr.shape[0] / PROC_H

    pad = 10
    X = int(max(0, (x - pad) * sx))
    Y = int(max(0, (y - pad) * sy))
    W = int(min(frame_bgr.shape[1] - X, (w0 + 2*pad) * sx))
    H = int(min(frame_bgr.shape[0] - Y, (h0 + 2*pad) * sy))

    roi = frame_bgr[Y:Y+H, X:X+W]
    box = (X, Y, W, H)
    return roi, mask, ratio, box

def preprocess_for_tflite(bgr):
    rgb = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)
    resized = cv2.resize(rgb, (in_w, in_h), interpolation=cv2.INTER_AREA)

    if in_dtype == np.float32:
        x = resized.astype(np.float32)
        x = x / 127.5 - 1.0
    else:
        x = resized.astype(in_dtype)

    return np.expand_dims(x, axis=0)

def dequant_if_needed(y):
    q = out_det.get("quantization", (0.0, 0))
    if q and q[0] not in (0.0, None):
        scale, zero = q
        y = (y.astype(np.float32) - zero) * scale
    return y.astype(np.float32)

def softmax_if_logits(y):
    s = float(y.sum())
    if (y.max() > 1.0) or (y.min() < 0.0) or (abs(s - 1.0) > 0.05):
        e = np.exp(y - np.max(y))
        y = e / e.sum()
    return y

def predict_top2(bgr):
    x = preprocess_for_tflite(bgr)
    interpreter.set_tensor(in_det["index"], x)
    interpreter.invoke()
    y = interpreter.get_tensor(out_det["index"])[0]
    y = softmax_if_logits(dequant_if_needed(y))

    top2 = np.argsort(y)[-2:][::-1]
    i1, i2 = int(top2[0]), int(top2[1])
    p1, p2 = float(y[i1]), float(y[i2])

    l1 = classes[i1] if i1 < len(classes) else f"class_{i1}"
    l2 = classes[i2] if i2 < len(classes) else f"class_{i2}"

    if (p1 < CONF_THR) or ((p1 - p2) < MARGIN_THR):
        return "Unknown / Not sure", p1, (l1, p1, l2, p2), (i1, i2)

    return l1, p1, (l1, p1, l2, p2), (i1, i2)

def draw_hud(frame, lines, color=(0, 255, 0)):
    y = 28
    for text in lines:
        cv2.putText(frame, text, (10, y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0,0,0), 3, cv2.LINE_AA)
        cv2.putText(frame, text, (10, y),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 1, cv2.LINE_AA)
        y += 24

# Camera init
cap = cv2.VideoCapture(CAM_INDEX, cv2.CAP_V4L2)
if not cap.isOpened():
    raise RuntimeError("The camera can't be opened. Try CAM_INDEX=1")

cap.set(cv2.CAP_PROP_FOURCC, cv2.VideoWriter_fourcc(*'MJPG'))
cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)

if SET_CAM_RESOLUTION:
    cap.set(cv2.CAP_PROP_FRAME_WIDTH,  CAM_W)
    cap.set(cv2.CAP_PROP_FRAME_HEIGHT, CAM_H)
if SET_CAM_FPS:
    cap.set(cv2.CAP_PROP_FPS, CAM_FPS)

real_w = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
real_h = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
real_fps = cap.get(cv2.CAP_PROP_FPS)
print(f"Camera actual: {real_w}x{real_h} @ {real_fps:.1f}fps")

main_win = "Plant Prediction (TFLite) - TURBO + Blynk"
mask_win = "Green Mask (small)"

cv2.namedWindow(main_win, cv2.WINDOW_NORMAL)
cv2.namedWindow(mask_win, cv2.WINDOW_NORMAL)
if RESIZE_WINDOWS:
    cv2.resizeWindow(main_win, WIN_MAIN_W, WIN_MAIN_H)
    cv2.resizeWindow(mask_win, WIN_MASK_W, WIN_MASK_H)

show_mask = False
use_roi   = True

last_pred = ("...", 0.0, ("...", 0.0, "...", 0.0), (-1, -1))  
frame_i = 0

print("Controls: q=quit | m=mask | r=toggle ROI")

try:
    while True:
        cap.grab(); cap.grab()
        ok, frame = cap.read()
        if not ok:
            break

        frame_i += 1

        mask = None
        green_ratio = -1.0
        box = None

        if USE_GREEN_FILTER and use_roi:
            roi, mask, green_ratio, box = crop_leaf_roi_fast(frame)
            target = roi if roi is not None else frame
        else:
            target = frame
            if USE_GREEN_FILTER:
                small = cv2.resize(frame, (PROC_W, PROC_H), interpolation=cv2.INTER_AREA)
                mask, green_ratio = green_mask_and_ratio(small)

        if frame_i % PREDICT_EVERY_N == 0:
            last_pred = predict_top2(target)

            pred_label, pred_prob, _, _ = last_pred
    
            handle_alerts(pred_label, pred_prob)

        pred_label, pred_prob, topinfo, _ = last_pred
        top1_lbl, top1_p, top2_lbl, top2_p = topinfo

        is_unknown = pred_label.startswith("Unknown")
        color = (0, 255, 255) if is_unknown else (0, 255, 0)

        if box is not None:
            X, Y, W, H = box
            cv2.rectangle(frame, (X, Y), (X+W, Y+H), (255, 255, 0), 2)

        lines = [
            f"Pred: {pred_label} ({pred_prob:.2f})",
            f"Top1: {top1_lbl} ({top1_p:.2f})" ,
            f"ROI: {'ON' if use_roi else 'OFF'} | Mask: {'ON' if show_mask else 'OFF'}",
        ]
        draw_hud(frame, lines, color=color)

        cv2.imshow(main_win, frame)
        if show_mask and mask is not None:
            cv2.imshow(mask_win, mask)

        key = cv2.waitKey(1) & 0xFF
        if key == ord("q") or key == 27:
            break
        elif key in (ord("m"), ord("M")):
            show_mask = not show_mask
        elif key in (ord("r"), ord("R")):
            use_roi = not use_roi

finally:
    cap.release()
    cv2.destroyAllWindows()
